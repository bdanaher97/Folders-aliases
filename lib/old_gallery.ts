/**
 * Gallery loading rules (TL;DR):
 *
 * - `.order` is AUTHORITATIVE anywhere it exists.
 *   Put it in any folder to control the order of:
 *     • subfolders (by folder name)
 *     • images (by image filename)
 *   Notes:
 *     • Unknown names are ignored.
 *     • Leftovers (not listed) keep their natural FS order and are appended.
 *     • Duplicates are allowed → duplicates will be rendered (useful for repeats).
 *
 * - `.folders` and `.images` are CONVENIENCE files, auto-generated by `npm run gen:orders`.
 *   They are overwritten every run and meant to be copy/paste helpers for building `.order`.
 *   Precedence: `.order` > `.folders` / `.images` > natural filesystem order.
 *
 * - Dev vs Prod:
 *   • Dev: just edit files and refresh; loader re-reads on each request.
 *   • Prod (Vercel): push changes to trigger a build; loader uses Node runtime (no Edge).
 */

import fs from "node:fs";
import path from "node:path";

export type GalleryNode = {
  name: string;
  slug: string; // URL-safe segment for routing
  fsPath: string; // absolute path on disk
  webPath: string; // "/Portfolio/..." for <Image src>
  coverWebPath?: string; // preview image (from first image, child cover, or dot folder cover)
  images?: string[]; // filenames only (omitted if sub-galleries exist)
  children?: GalleryNode[];
};

const ROOT = path.join(process.cwd(), "public", "Portfolio");
const MANIFEST_PATH = path.join(
  process.cwd(),
  "public",
  "portfolio-manifest.json"
); // optional

// Displayable image extensions
const IMAGE_EXT = new Set([
  ".jpg",
  ".jpeg",
  ".png",
  ".webp",
  ".gif",
  ".avif",
  ".bmp",
  ".tiff",
]);

function isImageFile(file: string) {
  return IMAGE_EXT.has(path.extname(file).toLowerCase());
}

function slugify(name: string) {
  // Keep spaces etc. working via URL encoding
  return encodeURIComponent(name);
}

function readDirSafe(p: string): string[] {
  try {
    return fs.readdirSync(p);
  } catch {
    return [];
  }
}

/** Read a simple newline list file, trimming and skipping blanks. */
function readListFile(absDir: string, file: string): string[] {
  const p = path.join(absDir, file);
  if (!fs.existsSync(p)) return [];
  try {
    return fs
      .readFileSync(p, "utf8")
      .split(/\r?\n/)
      .map((s) => s.trim())
      .filter(Boolean);
  } catch {
    return [];
  }
}

/** Ordering sources:
 *  - `.order`   (authoritative if present)
 *  - `.folders` (fallback list of subfolders)
 *  - `.images`  (fallback list of image filenames)
 */
function readOrder(absDir: string): string[] {
  return readListFile(absDir, ".order");
}
function readFolders(absDir: string): string[] {
  return readListFile(absDir, ".folders");
}
function readImages(absDir: string): string[] {
  return readListFile(absDir, ".images");
}

/** Apply a desired order to actual items, preserving original order for leftovers. */
function applyOrder(items: string[], orderNames: string[]): string[] {
  if (!orderNames.length) return items;
  const set = new Set(items);
  const inOrder = orderNames.filter((n) => set.has(n)); // keep only known names
  if (inOrder.length === items.length) return inOrder;
  const leftovers = items.filter((n) => !orderNames.includes(n));
  return [...inOrder, ...leftovers];
}

/** First displayable image path in a directory (used for cover detection). */
function firstImageInDir(
  absDir: string,
  relParts: string[]
): string | undefined {
  const webPath = "/" + ["Portfolio", ...relParts].join("/");
  const entries = readDirSafe(absDir);
  for (const e of entries) {
    const p = path.join(absDir, e);
    try {
      if (fs.statSync(p).isFile() && isImageFile(e)) {
        return `${webPath}/${e}`;
      }
    } catch {
      /* ignore */
    }
  }
  return undefined;
}

function buildNode(absPath: string, relParts: string[]): GalleryNode {
  const dirName = path.basename(absPath);
  const slug = slugify(dirName);
  const webPath = "/" + ["Portfolio", ...relParts].join("/");

  const entries = readDirSafe(absPath);

  // Split entries into files and directories
  let fileNames: string[] = [];
  let dirNames: string[] = [];
  for (const e of entries) {
    const p = path.join(absPath, e);
    try {
      const st = fs.statSync(p);
      if (st.isFile()) fileNames.push(e);
      else if (st.isDirectory()) dirNames.push(e);
    } catch {
      /* ignore missing */
    }
  }

  // Hide dot directories (metadata like .cover, or generated .images/.folders container)
  const dotDirs = dirNames.filter((d) => d.startsWith("."));
  let normalDirs = dirNames.filter((d) => !d.startsWith("."));

  // Images physically present at this level
  let imagesHere = fileNames.filter(isImageFile);

  // ----- ORDERING RULES -----
  // Directories: `.order` > `.folders` > natural FS order
  {
    const order = readOrder(absPath);
    const desired = order.length ? order : readFolders(absPath);
    normalDirs = applyOrder(normalDirs, desired);
  }
  // Images: `.order` > `.images` > natural FS order
  {
    const order = readOrder(absPath);
    const desired = order.length ? order : readImages(absPath);
    imagesHere = applyOrder(imagesHere, desired);
  }
  // --------------------------

  // Recursively build children from normal (non-dot) dirs — in the applied order
  const children = normalDirs.map((d) =>
    buildNode(path.join(absPath, d), [...relParts, d])
  );

  // Cover selection:
  // 1) First image inside a dot folder (e.g., .cover)
  // 2) First image in this folder
  // 3) First child's cover
  let coverWebPath: string | undefined;
  for (const dd of dotDirs) {
    const candidate = firstImageInDir(path.join(absPath, dd), [
      ...relParts,
      dd,
    ]);
    if (candidate) {
      coverWebPath = candidate;
      break;
    }
  }
  if (!coverWebPath && imagesHere.length)
    coverWebPath = `${webPath}/${imagesHere[0]}`;
  if (!coverWebPath && children[0]?.coverWebPath)
    coverWebPath = children[0].coverWebPath;

  // Container folders (with children) don’t expose images at this level
  const images = children.length
    ? undefined
    : imagesHere.length
    ? imagesHere
    : undefined;

  return {
    name: dirName,
    slug,
    fsPath: absPath,
    webPath,
    coverWebPath,
    images,
    children: children.length ? children : undefined,
  };
}

/** Manifest normalization (supports `dirName` vs `name`). */
function normalizeManifest(node: any): GalleryNode {
  const name = node.name ?? node.dirName ?? "";
  const slug = node.slug ?? slugify(name);
  const fsPath = node.fsPath ?? "";
  const webPath = node.webPath ?? "";
  const coverWebPath = node.coverWebPath;
  const images =
    Array.isArray(node.images) && node.images.length ? node.images : undefined;
  const children =
    Array.isArray(node.children) && node.children.length
      ? node.children.map((c: any) => normalizeManifest(c))
      : undefined;

  return { name, slug, fsPath, webPath, coverWebPath, images, children };
}

export async function getGalleryIndex(): Promise<GalleryNode> {
  const useManifest = process.env.GALLERY_USE_MANIFEST === "true";

  // Manifest mode (optional)
  if (useManifest && fs.existsSync(MANIFEST_PATH)) {
    const raw = fs.readFileSync(MANIFEST_PATH, "utf-8");
    const parsed = JSON.parse(raw);
    const root = normalizeManifest(parsed);
    const portfolio =
      root.children?.find(
        (n) =>
          decodeURIComponent(n.slug) === "Portfolio" || n.name === "Portfolio"
      ) ?? root;
    return portfolio;
  }

  // Filesystem mode
  if (!fs.existsSync(ROOT)) {
    // Safety: never crash builds if folder is missing
    return {
      name: "Portfolio",
      slug: "Portfolio",
      fsPath: ROOT,
      webPath: "/Portfolio",
      children: [],
    };
  }
  return buildNode(ROOT, []);
}

export async function getNodeBySlug(
  slugParts: string[]
): Promise<GalleryNode | null> {
  const index = await getGalleryIndex();
  let node: GalleryNode = index;
  for (const part of slugParts) {
    const decoded = decodeURIComponent(part);
    const next = node.children?.find(
      (c) => c.slug === part || c.name === decoded
    );
    if (!next) return null;
    node = next;
  }
  return node;
}

export function getBreadcrumbs(slugParts: string[]) {
  const items = [{ name: "Portfolio", href: "/portfolio" }];
  let href = "/portfolio";
  for (const part of slugParts) {
    href += "/" + part; // already encoded
    items.push({ name: decodeURIComponent(part), href });
  }
  return items;
}
